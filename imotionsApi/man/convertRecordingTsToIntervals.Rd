% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/imotionsApi.R
\name{convertRecordingTsToIntervals}
\alias{convertRecordingTsToIntervals}
\title{Convert recording's timestamps (relative to data recording start) into stimulus/scene/AOI timestamps (relative to the
interval first fragment start). Fragments are concatenated to give new array of timestamps in range [0,
concatenated duration of stimulus/scene/AOI].}
\usage{
convertRecordingTsToIntervals(recordingTs, intervals, keepTs = FALSE)
}
\arguments{
\item{recordingTs}{An array of recording's timestamps (relative to data recording start). Scalar, imSignals object as
returned by \code{\link{getSensorData}} or data.table with a column Timestamp are also accepted.}

\item{intervals}{An imInterval or imIntervalList object with start/end of a stimulus/scene/AOI as given by
\code{\link{getRespondentIntervals}} or \code{\link{getAOIRespondentData}}.}

\item{keepTs}{A boolean (or string) indicating whether timestamps falling outside an interval start/end should be
kept unchanged, by default there are discarded. If keepTs is set to "NA", timestamps falling outside
the interval will be replaced by NA. This will only work on array or scalar recordingTs.}
}
\value{
A new array/scalar/data.table with timestamps in range [0, concatenated duration of stimulus/scene/AOI].
}
\description{
Timestamps falling between an interval start/end will be kept, others will be discarded.
}
\examples{
\dontrun{
connection <- imotionsApi::imConnection("xxxxxxxx")
studies <- imotionsApi::listStudies(connection)
study <- imotionsApi::imStudy(connection, studies$id[1])
respondents <- imotionsApi::getRespondents(study)
sensors <- imotionsApi::getSensors(study, respondents[1, ])
signals <- imotionsApi::getSensorData(study, sensors[3, ])
intervals <- imotionsApi::getRespondentIntervals(study, respondents[1, ])

# get a new signal with timestamps in range [0, concatenated duration of stimulus/scene/AOI].
signals <- imotionsApi::convertRecordingTsToIntervals(signals, intervals[1, ])
}
}
